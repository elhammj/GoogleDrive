package com.drive.google.app.elham;import android.Manifest;import android.accounts.AccountManager;import android.app.Activity;import android.app.AlertDialog;import android.app.Dialog;import android.app.ProgressDialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.Color;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.os.AsyncTask;import android.os.Build;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.text.method.ScrollingMovementMethod;import android.util.Log;import android.view.View;import android.view.ViewGroup;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.LinearLayout;import android.widget.ListView;import android.widget.TextView;import android.widget.Toast;import com.google.android.gms.common.ConnectionResult;import com.google.android.gms.common.GoogleApiAvailability;import com.google.api.client.extensions.android.http.AndroidHttp;import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential;import com.google.api.client.googleapis.extensions.android.gms.auth.GooglePlayServicesAvailabilityIOException;import com.google.api.client.googleapis.extensions.android.gms.auth.UserRecoverableAuthIOException;import com.google.api.client.http.FileContent;import com.google.api.client.http.HttpTransport;import com.google.api.client.json.JsonFactory;import com.google.api.client.json.jackson2.JacksonFactory;import com.google.api.client.util.ExponentialBackOff;import com.google.api.services.drive.Drive;import com.google.api.services.drive.DriveScopes;import com.google.api.services.drive.model.File;import com.google.api.services.drive.model.FileList;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import pub.devrel.easypermissions.AfterPermissionGranted;import pub.devrel.easypermissions.EasyPermissions;public class MainActivity extends Activity  implements EasyPermissions.PermissionCallbacks {    static final int REQUEST_ACCOUNT_PICKER = 1000;    static final int REQUEST_AUTHORIZATION = 1001;    static final int REQUEST_GOOGLE_PLAY_SERVICES = 1002;    static final int REQUEST_PERMISSION_GET_ACCOUNTS = 1003;    private static final String BUTTON_TEXT = "Connect Google Drive";    private static final String PREF_ACCOUNT_NAME = "accountName";    private static final String[] SCOPES = {DriveScopes.DRIVE_METADATA_READONLY, DriveScopes.DRIVE_FILE, DriveScopes.DRIVE};    private static final int FILE_SELECT_CODE = 0;    private static final int PICKFILE_REQUEST_CODE = 1;    private static final int REQUEST_CODE_CREATOR = 2;    private static final int REQUEST_CODE_RESOLUTION = 3;    GoogleAccountCredential mCredential;    ProgressDialog mProgress, uploadProgress;    private String token;    private TextView mOutputText;    private Button mCallApiButton;    private com.google.api.services.drive.Drive mService = null;    private String TAG = "drive-quickstart";    private ArrayAdapter<String> arrayAdapter;    private List<File> files;    private File rootFile;    private ListView listview;    private Button addButton;    private Bitmap mBitmapToSave;    private static File insertFile(Drive service, String title, String description,                                   String parentId, String mimeType, String filename) {        // File's metadata.        File body = new File();        body.setName(title);        body.setDescription(description);        body.setMimeType(mimeType);        // Set the parent folder.        if (parentId != null && parentId.length() > 0) {            body.setParents(                    Arrays.asList(parentId));        }        // File's content.        java.io.File fileContent = new java.io.File(filename);        FileContent mediaContent = new FileContent(mimeType, fileContent);        try {            File file = service.files().create(body, mediaContent).execute();            return file;        } catch (IOException e) {            System.out.println("An error occured: " + e);            return null;        }    }    public static String getMimeType(String fileUrl)            throws java.io.IOException, MalformedURLException {        String type = null;        java.io.File f = new java.io.File(fileUrl);        URL u = f.toURI().toURL();        URLConnection uc = null;        uc = u.openConnection();        type = uc.getContentType();        return type;    }    public boolean isStoragePermissionGranted() {        if (Build.VERSION.SDK_INT >= 23) {            if (checkSelfPermission(android.Manifest.permission.WRITE_EXTERNAL_STORAGE)                    == PackageManager.PERMISSION_GRANTED) {                Toast.makeText(getApplicationContext(), "Permission is granted", Toast.LENGTH_SHORT).show();                return true;            } else {                Toast.makeText(getApplicationContext(), "Permission is revoked", Toast.LENGTH_SHORT).show();                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);                return false;            }        } else { //permission is automatically granted on sdk<23 upon installation            Toast.makeText(getApplicationContext(), "Permission Granted", Toast.LENGTH_SHORT).show();            Log.v(TAG, "Permission is granted");            return true;        }    }    /**     * Create the main activity.     * @param savedInstanceState previously saved instance data.     */    @Override    protected void onCreate(Bundle savedInstanceState) {        Log.i(TAG, "App init");        super.onCreate(savedInstanceState);        LinearLayout activityLayout = new LinearLayout(this);        LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(                LinearLayout.LayoutParams.MATCH_PARENT,                LinearLayout.LayoutParams.MATCH_PARENT);        activityLayout.setLayoutParams(lp);        activityLayout.setOrientation(LinearLayout.VERTICAL);        activityLayout.setPadding(16, 16, 16, 16);        ViewGroup.LayoutParams tlp = new ViewGroup.LayoutParams(                ViewGroup.LayoutParams.WRAP_CONTENT,                ViewGroup.LayoutParams.WRAP_CONTENT);        mCallApiButton = new Button(this);        mCallApiButton.setText(BUTTON_TEXT);        mCallApiButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                mCallApiButton.setEnabled(false);                mOutputText.setText("");                getResultsFromApi();                mCallApiButton.setEnabled(true);            }        });        activityLayout.addView(mCallApiButton);        mOutputText = new TextView(this);        mOutputText.setLayoutParams(tlp);        mOutputText.setPadding(16, 16, 16, 16);        mOutputText.setVerticalScrollBarEnabled(true);        mOutputText.setMovementMethod(new ScrollingMovementMethod());        mOutputText.setText(                "Click the \'" + BUTTON_TEXT + "\' button to test the API.");        activityLayout.addView(mOutputText);        addButton = new Button(getApplicationContext());        addButton.setText("Add File");        activityLayout.addView(addButton);        listview = new ListView(this.getApplicationContext());        activityLayout.addView(listview);        mProgress = new ProgressDialog(this);        mProgress.setMessage("Loading...");        uploadProgress = new ProgressDialog(this);        uploadProgress.setMessage("Uploading...");        setContentView(activityLayout);        addButton.setOnClickListener(new View.OnClickListener() {             @Override             public void onClick(View view) {                 if (isStoragePermissionGranted()) {                     Intent intent = new Intent(Intent.ACTION_GET_CONTENT);                     intent.setType("*/*");                     intent.addCategory(Intent.CATEGORY_OPENABLE);                     startActivityForResult(intent, PICKFILE_REQUEST_CODE);                 }             }         }        );        mCredential = GoogleAccountCredential.usingOAuth2(                getApplicationContext(), Arrays.asList(SCOPES))                .setBackOff(new ExponentialBackOff());    }    /**     * Attempt to call the API, after verifying that all the preconditions are     * satisfied. The preconditions are: Google Play Services installed, an     * account was selected and the device currently has online access. If any     * of the preconditions are not satisfied, the app will prompt the user as     * appropriate.     */    private void getResultsFromApi() {        if (!isGooglePlayServicesAvailable()) {            Log.i(TAG, "Play available");            acquireGooglePlayServices();        } else if (mCredential != null && mCredential.getSelectedAccountName() == null) {            Log.i(TAG, "Choosing Acount");            chooseAccount();        } else if (!isDeviceOnline()) {            mOutputText.setText("No network connection available.");        } else {            Log.i(TAG, "Making request");            new MakeRequestTask(mCredential).execute();            listview.setOnItemClickListener(new AdapterView.OnItemClickListener() {                public void onItemClick(AdapterView<?> parent, View view, int position, long id) {                    final File value = files.get(position);                    System.out.println("file id : " + value);                    runOnUiThread(new Runnable() {                        @Override                        public void run() {                    if (!isFinishing()) {                        new AlertDialog.Builder(MainActivity.this)                                .setTitle("Delete")                                .setMessage("Do you want to delete the selected file?")                                .setCancelable(true)                                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {                                    @Override                                    public void onClick(DialogInterface dialog, int which) {                                    }                                })                                .setPositiveButton("ok", new DialogInterface.OnClickListener() {                                    @Override                                    public void onClick(DialogInterface dialog, int which) {                                        new DeleteTask().execute(value);                                        getResultsFromApi();                                    }                                }).create().show();                    }                }                    });                }            });        }    }    /**     * Attempts to set the account used with the API credentials. If an account     * name was previously saved it will use that one; otherwise an account     * picker dialog will be shown to the user. Note that the setting the     * account to use with the credentials object requires the app to have the     * GET_ACCOUNTS permission, which is requested here if it is not already     * present. The AfterPermissionGranted annotation indicates that this     * function will be rerun automatically whenever the GET_ACCOUNTS permission     * is granted.     */    @AfterPermissionGranted(REQUEST_PERMISSION_GET_ACCOUNTS)    private void chooseAccount() {        if (EasyPermissions.hasPermissions(                this, Manifest.permission.GET_ACCOUNTS)) {            String accountName = getPreferences(Context.MODE_PRIVATE)                    .getString(PREF_ACCOUNT_NAME, null);            if (accountName != null) {                mCredential.setSelectedAccountName(accountName);                getResultsFromApi();            } else {                // Start a dialog from which the user can choose an account                startActivityForResult(                        mCredential.newChooseAccountIntent(),                        REQUEST_ACCOUNT_PICKER);            }        } else {            // Request the GET_ACCOUNTS permission via a user dialog            EasyPermissions.requestPermissions(                    this,                    "This app needs to access your Google account (via Contacts).",                    REQUEST_PERMISSION_GET_ACCOUNTS,                    Manifest.permission.GET_ACCOUNTS);        }    }    /**     * Called when an activity launched here (specifically, AccountPicker     * and authorization) exits, giving you the requestCode you started it with,     * the resultCode it returned, and any additional data from it.     * @param requestCode code indicating which activity result is incoming.     * @param resultCode code indicating the result of the incoming     *     activity result.     * @param data Intent (containing result data) returned by incoming     *     activity result.     */    @Override    protected void onActivityResult(            int requestCode, int resultCode, Intent data) {        super.onActivityResult(requestCode, resultCode, data);        switch (requestCode) {            case PICKFILE_REQUEST_CODE:                if (resultCode == RESULT_OK) {                    // Get the Uri of the selected file                    Uri uri = data.getData();                    ContentURIHelper helper = new ContentURIHelper();                    String filePath = helper.getPath(getApplicationContext(), uri);                    System.out.println("URI : " + filePath);                    Log.d(TAG, "File Uri: " + data.getData().getPath());                    // Get the path                    String path = filePath;                    java.io.File file = new java.io.File(path);                    String mimeType = null;                    try {                        mimeType = getMimeType(path);                    } catch (IOException e) {                        e.printStackTrace();                    }                    new CreateTask().execute(file.getName(), "description:" + file.getPath(), null, mimeType, file.getPath());                    Log.d(TAG, "File Path: " + path);                }                break;            case REQUEST_GOOGLE_PLAY_SERVICES:                if (resultCode != RESULT_OK) {                    mOutputText.setText(                            "This app requires Google Play Services. Please install " +                                    "Google Play Services on your device and relaunch this app.");                } else {                    getResultsFromApi();                }                break;            case REQUEST_ACCOUNT_PICKER:                if (resultCode == RESULT_OK && data != null &&                        data.getExtras() != null) {                    String accountName =                            data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);                    if (accountName != null) {                        SharedPreferences settings =                                getPreferences(Context.MODE_PRIVATE);                        SharedPreferences.Editor editor = settings.edit();                        editor.putString(PREF_ACCOUNT_NAME, accountName);                        editor.apply();                        mCredential.setSelectedAccountName(accountName);                        getResultsFromApi();                    }                }                break;            case REQUEST_AUTHORIZATION:                if (resultCode == RESULT_OK) {                    getResultsFromApi();                }                break;        }    }    /**     * Respond to requests for permissions at runtime for API 23 and above.     * @param requestCode The request code passed in     *     requestPermissions(android.app.Activity, String, int, String[])     * @param permissions The requested permissions. Never null.     * @param grantResults The grant results for the corresponding permissions     *     which is either PERMISSION_GRANTED or PERMISSION_DENIED. Never null.     */    @Override    public void onRequestPermissionsResult(int requestCode,                                           @NonNull String[] permissions,                                           @NonNull int[] grantResults) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        EasyPermissions.onRequestPermissionsResult(                requestCode, permissions, grantResults, this);    }    /**     * Callback for when a permission is granted using the EasyPermissions     * library.     * @param requestCode The request code associated with the requested     *         permission     * @param list The requested permission list. Never null.     */    @Override    public void onPermissionsGranted(int requestCode, List<String> list) {        // Do nothing.    }    /**     * Callback for when a permission is denied using the EasyPermissions     * library.     * @param requestCode The request code associated with the requested     *         permission     * @param list The requested permission list. Never null.     */    @Override    public void onPermissionsDenied(int requestCode, List<String> list) {        // Do nothing.    }    /**     * Checks whether the device currently has a network connection.     * @return true if the device has a network connection, false otherwise.     */    private boolean isDeviceOnline() {        ConnectivityManager connMgr =                (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);        NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();        return (networkInfo != null && networkInfo.isConnected());    }    /**     * Check that Google Play services APK is installed and up to date.     * @return true if Google Play Services is available and up to     *     date on this device; false otherwise.     */    private boolean isGooglePlayServicesAvailable() {        GoogleApiAvailability apiAvailability =                GoogleApiAvailability.getInstance();        final int connectionStatusCode =                apiAvailability.isGooglePlayServicesAvailable(this);        return connectionStatusCode == ConnectionResult.SUCCESS;    }    /**     * Attempt to resolve a missing, out-of-date, invalid or disabled Google     * Play Services installation via a user dialog, if possible.     */    private void acquireGooglePlayServices() {        GoogleApiAvailability apiAvailability =                GoogleApiAvailability.getInstance();        final int connectionStatusCode =                apiAvailability.isGooglePlayServicesAvailable(this);        if (apiAvailability.isUserResolvableError(connectionStatusCode)) {            showGooglePlayServicesAvailabilityErrorDialog(connectionStatusCode);        }    }    /**     * Display an error dialog showing that Google Play Services is missing     * or out of date.     * @param connectionStatusCode code describing the presence (or lack of)     *     Google Play Services on this device.     */    void showGooglePlayServicesAvailabilityErrorDialog(            final int connectionStatusCode) {        GoogleApiAvailability apiAvailability = GoogleApiAvailability.getInstance();        Dialog dialog = apiAvailability.getErrorDialog(                MainActivity.this,                connectionStatusCode,                REQUEST_GOOGLE_PLAY_SERVICES);        dialog.show();    }    private class DeleteTask extends AsyncTask<File, Void, File> {        @Override        protected void onPostExecute(File f) {            Toast.makeText(getApplicationContext(), "File " + f.getName() + " deleted", Toast.LENGTH_SHORT).show();        }        @Override        protected File doInBackground(File... files) {            File file = files[0];            try {                mService.files().delete(file.getId()).execute();            } catch (IOException e) {                e.printStackTrace();            }            return file;        }    }    private class CreateTask extends AsyncTask<String, String, File> {        /** application context. */        protected void onPreExecute() {            uploadProgress.show();        }        @Override        protected void onPostExecute(File file) {            uploadProgress.hide();            Toast.makeText(getApplicationContext(), "File " + file.getName() + " uploaded", Toast.LENGTH_SHORT).show();            getResultsFromApi();        }        @Override        protected File doInBackground(String... string) {            String title = string[0];            String description = string[1];            String parentId = string[2];            String mimetype = string[3];            String filename = string[4];            File body = new File();            body.setName(title);            body.setDescription(description);            body.setMimeType(mimetype);            // Set the parent folder.            if (parentId != null && parentId.length() > 0) {                body.setParents(                        Arrays.asList(parentId));            }            // File's content.            java.io.File fileContent = new java.io.File(filename);            FileContent mediaContent = new FileContent(mimetype, fileContent);            try {                File file = mService.files().create(body, mediaContent).execute();                return file;            } catch (IOException e) {                System.out.println("An error occured: " + e);                return null;            }        }    }    /**     * An asynchronous task that handles the Drive API call.     * Placing the API calls in their own task ensures the UI stays responsive.     */    private class MakeRequestTask extends AsyncTask<Void, Void, List<String>> {        private Exception mLastError = null;        public MakeRequestTask(GoogleAccountCredential credential) {            HttpTransport transport = AndroidHttp.newCompatibleTransport();            JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();            mService = new com.google.api.services.drive.Drive.Builder(                    transport, jsonFactory, credential)                    .setApplicationName("Drive API Android Quickstart")                    .build();        }        /**         * Background task to call Drive API.         * @param params no parameters needed for this task.         */        @Override        protected List<String> doInBackground(Void... params) {            try {                Log.i(TAG, "Trying to get data from api");                return getDataFromApi();            } catch (Exception e) {                mLastError = e;                cancel(true);                return null;            }        }        /**         * Fetch a list of up to 10 file names and IDs.         * @return List of Strings describing files, or an empty list if no files         *         found.         * @throws IOException         */        private List<String> getDataFromApi() throws IOException {            // Get a list of up to 10 files.            List<String> fileInfo = new ArrayList<String>();            FileList result = null;            rootFile = mService.files().get("root").execute();            Log.i(TAG, rootFile.getId());            result = mService.files().list()                    .setPageSize(50)                    .setQ("'" + rootFile.getId() + "' in parents")                    .execute();            files = result.getFiles();            if (files != null) {                for (File f : files) {                    fileInfo.add(String.format("%s (%s)\n",                            f.getName(), f.getId()));                }            }            return fileInfo;        }        @Override        protected void onPreExecute() {            mOutputText.setText("");            uploadProgress.hide();            mProgress.show();        }        @Override        protected void onPostExecute(List<String> output) {            mProgress.hide();            if (output == null || output.size() == 0) {                mOutputText.setText("No results returned.");            } else {                String[] fileNameArray = new String[output.size()];                int i = 0;                for (File file : files) {                    fileNameArray[i] = file.getName();                    i++;                }                arrayAdapter = new ArrayAdapter<String>(getApplicationContext(), android.R.layout.simple_list_item_1, fileNameArray);                listview.setAdapter(arrayAdapter);                listview.setBackgroundColor(Color.DKGRAY);            }        }        @Override        protected void onCancelled() {            mProgress.hide();            if (mLastError != null) {                if (mLastError instanceof GooglePlayServicesAvailabilityIOException) {                    showGooglePlayServicesAvailabilityErrorDialog(                            ((GooglePlayServicesAvailabilityIOException) mLastError)                                    .getConnectionStatusCode());                } else if (mLastError instanceof UserRecoverableAuthIOException) {                    startActivityForResult(                            ((UserRecoverableAuthIOException) mLastError).getIntent(),                            MainActivity.REQUEST_AUTHORIZATION);                } else {                    mOutputText.setText("The following error occurred:\n"                            + mLastError.getMessage());                }            } else {                mOutputText.setText("Request cancelled.");            }        }    }}